"""
StrategyDetectorWithPropagation 

StrategyDetector5Wfnï¾•ï¿½nW_&e_ï¾å¨¶~Y
"""

import numpy as np
import math
import warnings
import logging
from typing import Dict, List, Tuple, Optional, Union, Any
from datetime import datetime, timedelta
from functools import lru_cache

# n
from sailing_data_processor.strategy.detector import StrategyDetector
from sailing_data_processor.strategy.points import StrategyPoint, WindShiftPoint, TackPoint, LaylinePoint

# -
logger = logging.getLogger(__name__)

class StrategyDetectorWithPropagation(StrategyDetector):
    """
    nï¾•ï¿½nW_&eh
    
    StrategyDetectoré®–ï¿½5Wn,ï¾•ï¿½nW_
    ï¾˜ï½¦j&eï¾ï½¤_ï¾å¨¶~Y
    """
    
    def __init__(self, vmg_calculator=None, wind_fusion_system=None):
        """
        
        
        Parameters:
        -----------
        vmg_calculator : OptimalVMGCalculator, optional
            VMG_
        wind_fusion_system : WindFieldFusionSystem, optional
            q
        """
        # n
        super().__init__(vmg_calculator)
        
        # q-
        self.wind_fusion_system = wind_fusion_system
        
        # ï¾•ï¿½,-
        self.propagation_config = {
            'wind_shift_prediction_horizon': 1800,  # ï¾ˆï¿½,	
            'prediction_time_step': 300,           # ,B	
            'wind_shift_confidence_threshold': 0.7, # <$
            'min_propagation_distance': 1000,      # ,	
            'prediction_confidence_decay': 0.1,    # ,<pBB_	
            'use_historical_data': True            # Nn(
        }
    
    def detect_wind_shifts_with_propagation(self, course_data: Dict[str, Any], 
                                         wind_field: Dict[str, Any]) -> List[WindShiftPoint]:
        """
        nï¾•ï¿½nW_ï¾ï½¤n
        
        Parameters:
        -----------
        course_data : Dict[str, Any]
            P
        wind_field : Dict[str, Any]
            n4
            
        Returns:
        --------
        List[WindShiftPoint]
            U_ï¾ï½¤
        """
        if not wind_field or 'wind_direction' not in wind_field:
            return []
        
        # qLBp,ï¾ˆæ¤¿ï¿½
        predicted_shifts = []
        
        if self.wind_fusion_system and hasattr(self.wind_fusion_system, 'predict_wind_field'):
            try:
                # B
                reference_time = None
                if 'time' in wind_field:
                    reference_time = wind_field['time']
                elif 'start_time' in course_data:
                    reference_time = course_data['start_time']
                
                if reference_time:
                    # ,hB
                    horizon = self.propagation_config['wind_shift_prediction_horizon']
                    time_step = self.propagation_config['prediction_time_step']
                    
                    # ,Bï¾ï½¤gn4,
                    for t in range(time_step, horizon + 1, time_step):
                        target_time = reference_time + timedelta(seconds=t)
                        
                        # n4,ï¾–ï¿½
                        predicted_field = self.wind_fusion_system.predict_wind_field(
                            target_time=target_time,
                            current_wind_field=wind_field
                        )
                        
                        if predicted_field:
                            # ,n4Kï¾ˆï¿½
                            leg_shifts = self._detect_wind_shifts_in_legs(
                                course_data, predicted_field, target_time
                            )
                            
                            # ,<BLNgp
                            for shift in leg_shifts:
                                decay_factor = 1.0 - (t / horizon) * self.propagation_config['prediction_confidence_decay']
                                shift.shift_probability *= decay_factor
                            
                            predicted_shifts.extend(leg_shifts)
            
            except Exception as e:
                logger.error(f"ï¾ˆï¿½,-kLzW~W_: {e}")
        
        # (nn4gnn	
        current_shifts = super().detect_wind_shifts(course_data, wind_field)
        
        # (h,nï¾ˆå˜
        all_shifts = current_shifts + predicted_shifts
        
        # Yï¾ï½¤ï¾ˆé”ï½£
        filtered_shifts = self._filter_duplicate_shift_points(all_shifts)
        
        # $keDfï¾•ï½£
        threshold = self.propagation_config['wind_shift_confidence_threshold']
        final_shifts = [shift for shift in filtered_shifts 
                      if shift.shift_probability >= threshold]
        
        return final_shifts
    
    def _detect_wind_shifts_in_legs(self, course_data: Dict[str, Any], 
                                 wind_field: Dict[str, Any],
                                 target_time: datetime) -> List[WindShiftPoint]:
        """
        ï¿½ï½°ï¿½nï¾ˆï¿½
        
        Parameters:
        -----------
        course_data : Dict[str, Any]
            P
        wind_field : Dict[str, Any]
            n4
        target_time : datetime
            aB
            
        Returns:
        --------
        List[WindShiftPoint]
            U_ï¾ï½¤
        """
        # kLjD4ozï¾ˆç‚­
        if 'legs' not in course_data:
            return []
        
        shift_points = []
        
        # kWf
        for leg in course_data['legs']:
            # ï¾‘ï½¹ï¾ï½¤LjD4o
            if 'path' not in leg or 'path_points' not in leg['path']:
                continue
            
            path_points = leg['path']['path_points']
            
            # ï¾‘ï½¹ï¾ï½¤LjYN4o
            if len(path_points) < 2:
                continue
            
            # Mnï¾ï½¤n1
            prev_wind = None
            
            # ï¾‘ï½¹ï¾ï½¤kWf
            for i, point in enumerate(path_points):
                # Mn1
                if 'lat' not in point or 'lon' not in point:
                    continue
                
                lat, lon = point['lat'], point['lon']
                
                # 1ï¾–ï¿½
                wind = self._get_wind_at_position(lat, lon, target_time, wind_field)
                
                # 1Lï¾–æšMjD4o
                if not wind:
                    continue
                
                # Mnï¾ï½¤n1LB4ï¾ˆï¿½
                if prev_wind:
                    # n
                    dir_diff = self._angle_difference(
                        wind['direction'], prev_wind['direction']
                    )
                    
                    # ï¾’ï½¦H4
                    min_shift = self.config['min_wind_shift_angle']
                    if abs(dir_diff) >= min_shift:
                        # nMn(nhMnn	
                        midlat = (lat + path_points[i-1]['lat']) / 2
                        midlon = (lon + path_points[i-1]['lon']) / 2
                        
                        # <n!n1n<n	
                        confidence = min(
                            wind.get('confidence', 0.8),
                            prev_wind.get('confidence', 0.8)
                        )
                        
                        # 	'n
                        variability = max(
                            wind.get('variability', 0.2),
                            prev_wind.get('variability', 0.2)
                        )
                        
                        # ï¾ï½¤ï¾ˆç®ª
                        shift_point = WindShiftPoint(
                            position=(midlat, midlon),
                            time_estimate=target_time
                        )
                        
                        # 1-
                        shift_point.shift_angle = dir_diff
                        shift_point.before_direction = prev_wind['direction']
                        shift_point.after_direction = wind['direction']
                        shift_point.wind_speed = (prev_wind['speed'] + wind['speed']) / 2
                        
                        # <
                        raw_probability = confidence * (1.0 - variability)
                        
                        # ï¾’ï½¦keOQ
                        # 'Mj{iï¾ï¿½
                        angle_weight = min(1.0, abs(dir_diff) / 45.0)
                        shift_point.shift_probability = raw_probability * (0.5 + 0.5 * angle_weight)
                        
                        # ï¾†ï½¸ï¾ƒï½¯
                        strategic_score, note = self._calculate_strategic_score(
                            "wind_shift", "", "",
                            (midlat, midlon), target_time, wind_field
                        )
                        
                        shift_point.strategic_score = strategic_score
                        shift_point.note = note
                        
                        # k
                        shift_points.append(shift_point)
                
                # (n1X
                prev_wind = wind
        
        return shift_points
    
    def _filter_duplicate_shift_points(self, shift_points: List[WindShiftPoint]) -> List[WindShiftPoint]:
        """
        Yï¾ï½¤ï¾ˆé”ï½£
        
        Parameters:
        -----------
        shift_points : List[WindShiftPoint]
            ï¾ï½¤n
            
        Returns:
        --------
        List[WindShiftPoint]
            ï¾•ï½£nï¾ï½¤
        """
        if len(shift_points) <= 1:
            return shift_points
        
        filtered_points = []
        sorted_points = sorted(shift_points, 
                              key=lambda p: self._normalize_to_timestamp(p.time_estimate))
        
        for point in sorted_points:
            is_duplicate = False
            
            for existing in filtered_points:
                # MnkDK300m	
                position_close = self._calculate_distance(
                    point.position[0], point.position[1],
                    existing.position[0], existing.position[1]
                ) < 300
                
                # BkDK5	
                time_diff = self._get_time_difference_seconds(
                    point.time_estimate, existing.time_estimate
                )
                time_close = time_diff < 300
                
                # ï¾’ï½¦L^<WfDK15	
                angle_similar = abs(self._angle_difference(
                    point.shift_angle, existing.shift_angle
                )) < 15
                
                # a
                if position_close and time_close and angle_similar:
                    # <LD
                    if point.shift_probability > existing.shift_probability:
                        # Xï¾ï½¤ï¾ˆåœ°MH
                        filtered_points.remove(existing)
                        filtered_points.append(point)
                    
                    is_duplicate = True
                    break
            
            if not is_duplicate:
                filtered_points.append(point)
        
        return filtered_points
    
    def _normalize_to_timestamp(self, t) -> float:
        """
        è®’å€¥ï¿½ï¿½ç¸ºï½ªè­ã‚‹ä¿£é™¦ï½¨è¿´ï½¾ç¸ºä¹ï½‰é‚¨ï½±è³ï¿½ç¸ºåŠ±â—†UNIXç¹§ï½¿ç¹§ï½¤ç¹ï¿½ç¹§ï½¹ç¹§ï½¿ç¹ï½³ç¹åŠ±ï½’è´æ‡ˆï¿½ï¿½
        
        Parameters:
        -----------
        t : any
            è®’å€¥ï¿½ï¿½ç¸ºï½ªè­ã‚‹ä¿£é™¦ï½¨è¿´ï½¾(datetime, timedelta, int, floaté²ï¿½)
            
        Returns:
        --------
        float
            UNIXç¹§ï½¿ç¹§ï½¤ç¹ï¿½ç¹§ï½¹ç¹§ï½¿ç¹ï½³ç¹æ€œï½½ï½¢è ‘ä¸Šï¿½ï½®è›Ÿï½¤
        """
        if isinstance(t, datetime):
            # datetimeç¹§æ—¦NIXç¹§ï½¿ç¹§ï½¤ç¹ï¿½ç¹§ï½¹ç¹§ï½¿ç¹ï½³ç¹åŠ±â†“èŸç”»é‹¤
            return t.timestamp()
        elif isinstance(t, timedelta):
            # timedeltaç¹§å ¤ï½§åµâ†“èŸç”»é‹¤
            return t.total_seconds()
        elif isinstance(t, (int, float)):
            # è¬¨ï½°è›Ÿï½¤ç¸ºï½¯ç¸ºæ˜´ï¿½ï½®ç¸ºï½¾ç¸ºï½¾floatç¸ºï½§éœ‘æ–â˜†
            return float(t)
        elif isinstance(t, dict):
            # éœæ¨Šå¶Œè™ä¹ï¿½ï½®è£ï½´èœ·ï¿½
            if 'timestamp' in t:
                # timestampç¹§ï½­ç¹ï½¼ç¹§å‘ˆæˆŸç¸ºï½¤éœæ¨Šå¶Œç¸ºï½®è£ï½´èœ·ï¿½
                return float(t['timestamp'])
            else:
                # timestampç¹§ï½­ç¹ï½¼ç¸ºå¾Œâ†‘ç¸ºï¿½éœæ¨Šå¶Œç¸ºï½®è£ï½´èœ·åŒ»ï¿½ï½¯ç¹§ï½¨ç¹ï½©ç¹ï½¼é«¦ï½²è±ï½¢ç¸ºï½®ç¸ºæº˜ï½è¾Ÿï½¡é«¯ä»™ï½¤ï½§ç¹§å®šï½¿æ–â˜†
                return float('inf')
        elif isinstance(t, str):
            try:
                # è¬¨ï½°è›Ÿï½¤è­ï¿½èŸ„æ€œï¿½åŠ±ï¿½ï½®è£ï½´èœ·åŒ»ï¿½ï½¯è¬¨ï½°è›Ÿï½¤ç¸ºï½«èŸç”»é‹¤
                return float(t)
            except ValueError:
                try:
                    # ISOè –ï½¢è ‘ä¸Šï¿½ï½®è­Œï½¥è­ã‚ˆæšèŸ„æ€œï¿½ï¿½
                    dt = datetime.fromisoformat(t.replace('Z', '+00:00'))
                    return dt.timestamp()
                except ValueError:
                    # èŸç”»é‹¤ç¸ºï½§ç¸ºé˜ªâ†‘ç¸ºï¿½è£ï½´èœ·åŒ»ï¿½ï½¯è¾Ÿï½¡é«¯ä»™ï½¤ï½§
                    return float('inf')
        else:
            # ç¸ºæ˜´ï¿½ï½®è‰æ‚¶ï¿½ï½®è™ä¹ï¿½ï½¯è­ï¿½èŸ„æ€œï¿½åŠ±â†“èŸç”»é‹¤ç¸ºåŠ±â€»ç¸ºä¹ï½‰è¬¨ï½°è›Ÿï½¤è›¹ï¿½
            try:
                return float(str(t))
            except ValueError:
                # èŸç”»é‹¤ç¸ºï½§ç¸ºé˜ªâ†‘ç¸ºï¿½è£ï½´èœ·åŒ»ï¿½ï½¯è¾Ÿï½¡é«¯ä»™ï½¤ï½§ï¿½ï½¼äº¥ï½¯ï½¾è ¢æ‡Šâ˜†ç¹§çŸ©ï¿½ï¿½è æ“¾ï½¼ï¿½
                return float('inf')
    def _get_time_difference_seconds(self, time1, time2) -> float:
        """
        pjBï¾—æ¸¡gï¾–é›„p
        
        Parameters:
        -----------
        time1, time2 : any
            YB$datetime, timedelta, int, float, etc	
            
        Returns:
        --------
        float
            B		gMjD4o!P'
        """
        # !nBcWfnv$Y
        try:
            ts1 = self._normalize_to_timestamp(time1)
            ts2 = self._normalize_to_timestamp(time2)
            
            # DZKL!P'n4o
            if ts1 == float('inf') or ts2 == float('inf'):
                return float('inf')
                
            return abs(ts1 - ts2)
        except Exception as e:
            logger.error(f"B: {e}")
            # LzW_4o!P'Y
            return float('inf')
    
    def detect_optimal_tacks(self, course_data: Dict[str, Any], 
                          wind_field: Dict[str, Any]) -> List[TackPoint]:
        """
        ijï¾ƒï½¯ï¾ï½¤ï¾ˆï¿½
        
        Parameters:
        -----------
        course_data : Dict[str, Any]
            P
        wind_field : Dict[str, Any]
            n4
            
        Returns:
        --------
        List[TackPoint]
            U_iï¾ƒï½¯ï¾ï½¤
        """
        # VMG_LjQpzï¾ˆç‚­
        if not self.vmg_calculator:
            logger.warning("VMGCalculatorL-UfDjD_iï¾ƒï½¯ï¾ï½¤nLgM~[")
            return []
        
        # hXï¾…ï¿½(ek5	
        return super().detect_optimal_tacks(course_data, wind_field)
    
    def detect_laylines(self, course_data: Dict[str, Any], 
                      wind_field: Dict[str, Any]) -> List[LaylinePoint]:
        """
        ï¾ï½¤ï¾ˆï¿½
        
        Parameters:
        -----------
        course_data : Dict[str, Any]
            P
        wind_field : Dict[str, Any]
            n4
            
        Returns:
        --------
        List[LaylinePoint]
            U_ï¾ï½¤
        """
        # VMG_LjQpzï¾ˆç‚­
        if not self.vmg_calculator:
            logger.warning("VMGCalculatorL-UfDjD_ï¾ï½¤nLgM~[")
            return []
        
        # hXï¾…ï¿½(ek5	
        return super().detect_laylines(course_data, wind_field)
    
    def _determine_tack_type(self, bearing: float, wind_direction: float) -> str:
        """
        ï¾ƒï½¯/	$
        
        Parameters:
        -----------
        bearing : float
            Gn2L	
        wind_direction : float
            L9DfO	
            
        Returns:
        --------
        str
            ï¾ƒï½¯ ('port'~_o'starboard')
        """
        # h2Lnï¾’ï½¦
        relative_angle = self._angle_difference(bearing, wind_direction)
        
        # ï¾’ï½¦g$j7KLeï¾ˆï½¿ï¾ƒï½¯	
        return 'port' if relative_angle < 0 else 'starboard'
    
    def _calculate_strategic_score(self, maneuver_type: str, 
                                 before_tack_type: str, 
                                 after_tack_type: str,
                                 position: Tuple[float, float], 
                                 time_point, 
                                 wind_field: Dict[str, Any]) -> Tuple[float, str]:
        """
        n&e
        
        Parameters:
        -----------
        maneuver_type : str
            n.^ ('tack', 'gybe', 'wind_shift'I)
        before_tack_type : str
            Mnï¾ƒï½¯ ('port'~_o'starboard')
        after_tack_type : str
            ï¾ç³»ï¾ƒï½¯ ('port'~_o'starboard')
        position : Tuple[float, float]
            nMn, L	
        time_point : any
            nB
        wind_field : Dict[str, Any]
            n4
            
        Returns:
        --------
        Tuple[float, str]
            (&e0-1	, )
        """
        score = 0.5  # ï¾•ï½©o-$
        note = "j&eï¾ï¿½'"
        
        # 1ï¾–ï¿½
        wind = self._get_wind_at_position(position[0], position[1], time_point, wind_field)
        
        if not wind:
            return score, note
        
        # ï¾ï½¿Thkpj
        if maneuver_type == 'tack':
            # ï¾ƒï½¯n4
            wind_shift_probability = wind.get('variability', 0.2)
            
            # ï¾ƒï½¯
            if before_tack_type != after_tack_type:
                # ï¾ƒï½¯gW_4
                if wind_shift_probability > 0.6:
                    # 	'nDgoï¾ƒï½¯Lï¾ï¿½
                    score = 0.8
                    note = "n	kY_nï¾ï¼‰ï¾ƒï½¯"
                elif wind.get('confidence', 0.5) < 0.4:
                    # <'nNDn-gnï¾ƒï½¯
                    score = 0.3
                    note = "n<'LND-gnï¾ƒï½¯ï¿½ï½¹ï½¯B	"
                else:
                    # jï¾ƒï½¯
                    score = 0.5
                    note = "jï¾ƒï½¯"
            
        elif maneuver_type == 'wind_shift':
            # n4
            shift_angle = abs(self._angle_difference(
                wind.get('direction', 0), 
                wind.get('before_direction', wind.get('direction', 0))
            ))
            
            if shift_angle > 20:
                # 'Mj
                score = 0.9
                note = "ï¾ï¼‰	ï¾ï½¤"
            elif shift_angle > 10:
                # -n
                score = 0.7
                note = "YyM	"
            else:
                # Uj
                score = 0.5
                note = "j	"
            
            # n	n
            if 'before_speed' in wind and 'speed' in wind:
                speed_change = abs(wind['speed'] - wind['before_speed'])
                if speed_change > 5:
                    score += 0.1
                    note += "'MO		"
        
        # nMnL	kDKï¾ƒï½¯
        if 'lat_grid' in wind_field and 'lon_grid' in wind_field:
            # tek	
            pass
        
        return min(1.0, score), note
    
    def _filter_duplicate_tack_points(self, tack_points: List[TackPoint]) -> List[TackPoint]:
        """
        Yï¾ƒï½¯ï¾ï½¤ï¾ˆé”ï½£
        
        Parameters:
        -----------
        tack_points : List[TackPoint]
            ï¾ƒï½¯ï¾ï½¤n
            
        Returns:
        --------
        List[TackPoint]
            ï¾•ï½£nï¾ƒï½¯ï¾ï½¤
        """
        # o _filter_duplicate_shift_points h^<
        if len(tack_points) <= 1:
            return tack_points
        
        filtered_points = []
        for point in tack_points:
            is_duplicate = False
            
            for existing in filtered_points:
                # MnkDK
                position_close = self._calculate_distance(
                    point.position[0], point.position[1],
                    existing.position[0], existing.position[1]
                ) < 200  # ï¾ƒï½¯(koWDg$
                
                # VMG9L^<WfDK
                vmg_similar = abs(point.vmg_gain - existing.vmg_gain) < 0.05
                
                if position_close and vmg_similar:
                    # VMG9L'MD
                    if point.vmg_gain > existing.vmg_gain:
                        filtered_points.remove(existing)
                        filtered_points.append(point)
                    
                    is_duplicate = True
                    break
            
            if not is_duplicate:
                filtered_points.append(point)
        
        return filtered_points
    
    def _filter_duplicate_laylines(self, layline_points: List[LaylinePoint]) -> List[LaylinePoint]:
        """
        Yï¾ï½¤ï¾ˆé”ï½£
        
        Parameters:
        -----------
        layline_points : List[LaylinePoint]
            ï¾ï½¤n
            
        Returns:
        --------
        List[LaylinePoint]
            ï¾•ï½£nï¾ï½¤
        """
        # o _filter_duplicate_shift_points h^<
        if len(layline_points) <= 1:
            return layline_points
        
        filtered_points = []
        for point in layline_points:
            is_duplicate = False
            
            for existing in filtered_points:
                # XxnK
                same_mark = point.mark_id == existing.mark_id
                
                # MnkDK
                position_close = self._calculate_distance(
                    point.position[0], point.position[1],
                    existing.position[0], existing.position[1]
                ) < 300
                
                if same_mark and position_close:
                    # <LD
                    if point.confidence > existing.confidence:
                        filtered_points.remove(existing)
                        filtered_points.append(point)
                    
                    is_duplicate = True
                    break
            
            if not is_duplicate:
                filtered_points.append(point)
        
        return filtered_points
    
    def _calculate_distance(self, lat1: float, lon1: float, lat2: float, lon2: float) -> float:
        """
        2n	
        
        Parameters:
        -----------
        lat1, lon1 : float
            ï¾‹ï½¹nL
        lat2, lon2 : float
            BnL
            
        Returns:
        --------
        float
            	
        """
        # 0nJ	
        R = 6371000
        
        # Lé®‘ï½¢k	
        lat1_rad = math.radians(lat1)
        lon1_rad = math.radians(lon1)
        lat2_rad = math.radians(lat2)
        lon2_rad = math.radians(lon2)
        
        # 
        dlat = lat2_rad - lat1_rad
        dlon = lon2_rad - lon1_rad
        
        # Haversinel
        a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        distance = R * c
        
        return distance